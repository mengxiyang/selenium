import datetime as pydateimport osimport xml.saximport loggingimport refrom optparse import OptionParserfrom collections import Counter#npm_dir_root="/opt/xoam/data/northbound/pm/ready"npm_dir_root="./ready"global logPMParserlogging.basicConfig(level=logging.DEBUG,                    format='%(asctime)s:%(filename)s[line:%(lineno)d] %(levelname)s %(message)s',                    datefmt='%a, %d %b %Y %H:%M:%S',                    filename = os.path.join(os.getcwd(),'Detail.log'),                    filemode='w')logPMParser=logging.getLogger('pmcmp.py')def find_pm_file(path,timestamp):	for i in os.listdir(path):		if (i.find(timestamp) != -1):			return i        else:            return "missing"	 def get_src_file():   if options.time == True:       nowtime = pydate.datetime.now()   else:       pm_time = options.time       nowtime = pydate.datetime.strptime(pm_time,"%Y%m%d%H%M%S")   npm_interval=options.interval   round = 60/npm_interval   timeshift=nowtime.minute%npm_interval   filelist={}   npm_dir=npm_dir_root + "/" + options.nename   for i in range(1,round+1):    timeshift += npm_interval    time_delta = nowtime + pydate.timedelta(minutes = -timeshift)    pm_timestamp = time_delta.strftime("%Y%m%d") + "-" + time_delta.strftime("%H%M")    pm_file = find_pm_file(npm_dir,pm_timestamp)    if (pm_file != "missing") :        filelist[time_delta.minute] = npm_dir + "/" + pm_file    i=i+1   return filelistdef compare_pm(srcfile, baseInfo):    srcInfo=getPmInfo(srcfile)    for a,b in baseInfo.items():        if(a=="FileHeader"):            for c,d in b.items():                if srcInfo[a].has_key(c) == True:                    if (srcInfo[a][c] != baseInfo[a][c]):                        logPMParser.error(srcfile + " data accuracy test failed.")                        logPMParser.error("failed." + a + "/" + c +" value is " + srcInfo[a][c] + ", and the expected result is:" + baseInfo[a][c])                        return -1                else:                    logPMParser.error(srcfile + " data accuracy test failed.")                    logPMParser.error("attribute:" + a + "/" + c + " is missing.")                    return -1        elif(a=="PMData"):            for i,j in b.items():                if srcInfo[a].has_key(i) == True:                    for v1,v2 in j.items():                        if srcInfo[a][i].has_key(v1) == True:                            if srcInfo[a][i][v1] != baseInfo[a][i][v1]:                                logPMParser.error(srcfile + " data accuracy test failed.")                                logPMParser.error("PM counter:" + a + "/" + i + "/" + v1 + " value is " + str(srcInfo[a][i][v1]) + ", and the expected result is:" + str(baseInfo[a][i][v1]))                                return -1                        else:                            logPMParser.error(srcfile + " data accuracy test failed.")                            logPMParser.error("PM counter:" + a + "/"+ i + "/" + v1 + " is missing.")                            return -1                else:                    logPMParser.error(srcfile + " data accuracy test failed.")                    logPMParser.error("PM DN:" + a + "/" + i + " missing.")                    return -1    for a, b in srcInfo.items():        if(a=="FileHeader"):            for c,d in b.items():                if baseInfo[a].has_key(c) == False:                    logPMParser.error(srcfile + " accuracy test failed ")                    logPMParser.error("extra attribute:" + a + "/" + c + " in " + srcfile)                    return -1        elif(a=="PMData"):            for i,j in b.items():                if baseInfo[a].has_key(i) == False:                    logPMParser.error(srcfile + " accuracy test failed ")                    logPMParser.error("extra PM DN:" + a + "/" + i + " in " + srcfile)                    return -1                else:                    for v1,v2 in j.items():                        if baseInfo[a][i].has_key(v1) == False:                            logPMParser.error(srcfile + " accuracy test failed ")                            logPMParser.error("extra PM counter:" + a + "/" + i + "/" + v1 + " in " + srcfile)                            return -1class PMSaxHandler(xml.sax.ContentHandler):    def __init__(self):        xml.sax.ContentHandler.__init__(self)        logPMParser.info('SAX handler init.')        self.node = {}        self.isHeader = False        self.headerPara = {}        self.counters = {}        self.counter = ""        self.lics = {}        self.isLic = False        self.key = None        self.isCounter = False        self.dn = ""        def startElement(self, name, attrs):        if(name == "FileHeader"):            self.isHeader = True            logPMParser.info('Found a header information.')        elif(name == "Pm"):            self.isLic = True            self.dn = attrs["Dn"].strip().encode('utf-8')            logPMParser.info('Found a lic information.')        elif(name == "V"):            self.isCounter = True            self.counter = attrs["i"].strip().encode('utf-8')        self.key = name.strip().encode('utf-8')        def characters(self, content):        content = content.strip().encode('utf-8')        if(self.isHeader):            if('FileHeader' != self.key and 'BeginTime' != self.key and 'EndTime' != self.key):                if(self.key is not None):                    self.headerPara[self.key] = content        elif(self.isLic and self.isCounter):            if('V' == self.key):                if(self.key is not None):                    self.counters[self.counter] = int(content)        def endElement(self, name):        if(name == self.key):            self.key = None        if('Pm' == name):            self.isLic = False            self.lics[self.dn] =  self.counters            self.counters = {}        if('FileHeader' == name):            self.isHeader = False        if('V' == name):            self.isCounter = False                    def endDocument(self):            self.node["FileHeader"] = self.headerPara        self.node["PMData"] = self.lics        logPMParser.info('End the parsing of XML.')       def getPmInfo(xmlpath):    parser = xml.sax.make_parser()    handler = PMSaxHandler()    parser.setContentHandler(handler)    parser.parse(open(xmlpath, 'r'))    return handler.nodedef getOptions():    parser = OptionParser(usage="usage: %prog -n -t [-i] [-p] [-l]")    parser.add_option("-i","--interval",action="store",type="int",dest="interval",default=5, help="specify the northbound pm file interval[5|15]")    parser.add_option("-t","--type",action="store",type="string",dest="ne_type",default="True", help="specify the netype")    parser.add_option("-p","--timestamp",action="store",type="string",dest="time",default="True", help="specify the timestamp from which to start comparing the pm file[YYmmddHHMMSS]")    parser.add_option("-n","--nename",action="store",type="string",dest="nename",default="True",help="specify the nename")    parser.add_option("-l","--licid",action="store",type="string",dest="licid",default="True",help="specify the licId")    (options,args)=parser.parse_args()    if(options.ne_type.lower()!='sgsn' and options.ne_type.lower()!='mme' and options.ne_type.lower()!='sgw' and options.ne_type.lower()!='pgw' and options.ne_type.lower()!='ocgas' and options.ne_type.lower()!='sbc'):        print "Only support netype like: SGSN,MME,SGW,PGW,OCGAS and SBC."        parser.print_help()        return -1        print "-n is mandatory to input."        parser.print_help()        return -1    if (options.ne_type == True):        print "-t is mandatory to input."        parser.print_help()        return -1    if (options.interval % 5):        print "incorrect interval.It must be mutiples of 5"        parser.print_help()        return -1    pattern = re.compile(r'\d{14}')    match = pattern.match(options.time)    if match == None:        print "The pm timestamp should be in format of YYmmddHHMMSS."        parser.print_help()        return -1    return optionsdef getBaseInfo():    dn=""    oldtime=""    tmp={}    node={}    InfoModelReferenced=""    nename=options.nename    netype=options.ne_type.upper()    baseInfo={}    counters=[]    lics={}    fileheader={}    pmdata_path="./conf/counters/" + options.ne_type.lower() +".cfg"    filehead_path="./conf/counters/fileheader.cfg"    #read fileheader.cfg    f=open(filehead_path,"r")    for i in f.readlines():        i=i.strip()        if(i and i.startswith('#') == False):            key,value=i.split("=",1)            fileheader[key]=value            fileheader["InfoModelReferenced"]=netype+"-PM-V2.0.0"    f.close()    #read ne.cfg    f=open(pmdata_path,"r")    for i in f.readlines():        i=i.strip('\n')        if(i and i.startswith('#') == False):            key,value=i.split("=",1)            if(options.ne_type.lower()=='ocgas'):                time,licid=key.split("-")                time=int(time)            else:                time=int(key)                licid=options.licid            dn="DC=Ericsson,SubNetwork=1,ManagedElement="+nename+"|"+nename+",LIC="+licid            counters=value.split(",")            if(time!=oldtime):                lics={}            i=0            for i in range(0, len(counters)):                tmp[str(i+1)]=int(counters[i])            lics[dn]=tmp            node["PMData"]=lics            node["FileHeader"]=fileheader            baseInfo[time]=node            i=i+1            oldtime=time            node={}            tmp={}    f.close()    return baseInfodef getBaseInfo_muti_rop():    pm_interval=options.interval    node_m={}    baseinfo={}    lics={}    round=pm_interval/5    node_5=getBaseInfo()    node_m[0]=node_5[0]    time1=0    time2=time1+5    for i in range(1,60/pm_interval+1):        while(time2-time1<5*round):            pmdata_m=node_m[time1]["PMData"]            for lic,counters in pmdata_m.items():                if(node_5[time2]["PMData"].has_key(lic)==True):                    X,Y=Counter(node_5[time2]["PMData"][lic]),Counter(counters)                    z=dict(X+Y)                    pmdata_m[lic]=z            node_m[time1]["PMData"]=pmdata_m            time2+=5        time1+=pm_interval        if(time1==60):            time1=0        time2=time1+5        node_m[time1]=node_5[time1]        i+=1    return node_mif __name__ == '__main__':    options = getOptions()    if options==-1:        exit()    else:        nename = options.nename        licid = options.licid        netype = options.ne_type.lower()    npm_dir= npm_dir_root + "/" + options.nename    cfg_file='./conf/counters/' + netype + ".cfg"    if(not os.path.exists(cfg_file)):        print "the ne cfg file not existed."        exit()    if(not os.path.exists(npm_dir)):        print "The northbound pm path not existed."        exit()    srcfile=get_src_file()    if(options.interval==5):        base_data=getBaseInfo()    else:        base_data=getBaseInfo_muti_rop()    len_src_file=len(srcfile.items())    success_num = 0    fail_num = 0    if(len_src_file==0):        print "no required pm files can be found in " + npm_dir        exit()    print "Start PM comparing............"    for time,file in srcfile.items():        if base_data.has_key(time) == True:            flag = compare_pm(file,base_data[time])            if flag == -1:                fail_num += 1                print file + " accuracy test failed. For failed reason pls refer to Detail.log"            else:                success_num += 1                logPMParser.debug(file + " accuracy test success.")                print file + " accuracy test success"    print "Finish PM comparing. Total:" + str(len_src_file) + " files.Success:" + str(success_num) + " Fail:" + str(fail_num)               