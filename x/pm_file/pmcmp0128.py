import datetime as pydateimport osimport xml.saximport loggingimport refrom optparse import OptionParserfrom com.ericsson.xn.commons import PyPropertiesfrom decimal import *# npm_dir_root="/opt/xoam/data/northbound/pm/ready"run_dir = os.path.normpath(os.path.dirname(os.path.abspath(__file__)))npm_dir_root = os.path.join(run_dir, "ready")lic_counters_dir = run_dir + os.sep + "conf" + os.sep + "lic_counters"me_counters_dir = run_dir + os.sep + "conf" + os.sep + "me_counters"counter_properties_dir = run_dir + os.sep + "conf" + os.sep + "counter_properties"global logPMParserlogging.basicConfig(level=logging.DEBUG,                    format='%(asctime)s:%(filename)s[line:%(lineno)d] %(levelname)s %(message)s',                    datefmt='%a, %d %b %Y %H:%M:%S',                    filename=os.path.join(os.getcwd(), 'Detail.log'),                    filemode='w')logPMParser = logging.getLogger('pmcmp.py')def load_counter_properties(inpath):    counter_properties = PyProperties.Properties(inpath).dict_info()    return counter_properties    def get_counter_multi_algorithm(counter_properties,counter_name,type):    if(type == "lic"):        return counter_properties["lic_multi_algorithm"].split(",")[counter_name]    elif(type == "me"):        return counter_properties["me_multi_algorithm"].split(",")[counter_name]    def get_counter_datatype(counter_properties,counter_name,type):    if(type == "lic"):        return counter_properties["lic_counter_datatype"].split(",")[counter_name]    elif(type == "me"):        return counter_properties["me_counter_datatype"].split(",")[counter_name]        def sum_counter(DN,counter_name,counter_value,time,datatype):    if(datatype=="lic"):        pmdata_5=get_pm_data_lic(options.ne_type.lower())    elif(datatype=="me"):        pmdata_5=get_pm_data_me(options.ne_type.lower())        round = options.interval/5        for i in range(1,round):           nexttime=time+5        if(nexttime==60):            nexttime=0        new_counter_value = counter_value + pmdata_5[nexttime][DN][counter_name]        counter_value=new_counter_value        time=time+5        i=i+1        return new_counter_valuedef avg_counter(DN,counter_name,counter_value,time,datatype):    sum_value = sum_counter(DN,counter_name,counter_value,time,datatype)    round = options.interval/5    avg_value=sum_value/round    avg_value = Decimal("%.2f"%avg_value)    return avg_valuedef last_counter(DN,counter_name,counter_value,time,datatype):    if(datatype=="lic"):        pmdata_5=get_pm_data_lic(options.ne_type.lower())    elif(datatype=="me"):        pmdata_5=get_pm_data_me(options.ne_type.lower())    round=options.interval/5    for i in range(1,round):           nexttime=time+5        if(nexttime==60):            nexttime=0               new_value = pmdata_5[nexttime][DN][counter_name]        time=time+5        i=i+1        return new_valuedef max_counter(DN,counter_name,counter_value,time,datatype):    if(datatype=="lic"):        pmdata_5=get_pm_data_lic(options.ne_type.lower())    elif(datatype=="me"):        pmdata_5=get_pm_data_me(options.ne_type.lower())    round=options.interval/5    for i in range(1,round):           nexttime=time+5        if(nexttime==60):            nexttime=0        if (counter_value < pmdata_5[nexttime][DN][counter_name]):            new_value= pmdata_5[nexttime][DN][counter_name]        else:            new_value=counter_value        time=time+5        i=i+1        return new_value            def find_xml_file(path, timestamp):    for i in os.listdir(path):        if (i.find(timestamp) != -1):            return i    else:        return "missing"def get_file_list():    if options.time == "":        nowtime = pydate.datetime.now()    else:        pm_time = options.time        nowtime = pydate.datetime.strptime(pm_time, "%Y%m%d%H%M")    npm_interval = options.interval    round = 60 / npm_interval    timeshift = nowtime.minute % npm_interval    filelist = {}    npm_dir = npm_dir_root + os.path.sep + options.nodeid    for i in range(1, round + 1):        timeshift += npm_interval        time_delta = nowtime + pydate.timedelta(minutes=-timeshift)        pm_timestamp = time_delta.strftime("%Y%m%d") + "-" + time_delta.strftime("%H%M")        pm_file = find_xml_file(npm_dir, pm_timestamp)        if (pm_file != "missing"):            filelist[time_delta.minute] = npm_dir + "/" + pm_file        i = i + 1    return filelistdef compare_data(srcfile, baseInfo):    srcInfo = parse_xml_file(srcfile)    print "++++++++++++xmlfile+++++++++++++++"    print srcfile    print srcInfo    print "+++++++++++expectresult++++++++++++"    print baseInfo    for a, b in baseInfo.items():        if (a == "FileHeader"):            for c, d in b.items():                if srcInfo[a].has_key(c) == True:                    if (srcInfo[a][c] != baseInfo[a][c]):                        logPMParser.error(srcfile + " data accuracy test failed.")                        logPMParser.error(                            "failed." + a + "/" + c + " value is " + srcInfo[a][c] + ", and the expected result is:" +                            baseInfo[a][c])                        return -1                else:                    logPMParser.error(srcfile + " data accuracy test failed.")                    logPMParser.error("attribute:" + a + "/" + c + " is missing.")                    return -1        elif (a == "PMData"):            for i, j in b.items():                if srcInfo[a].has_key(i) == True:                    for v1, v2 in j.items():                        if srcInfo[a][i].has_key(v1) == True:                            if srcInfo[a][i][v1] != baseInfo[a][i][v1]:                                logPMParser.error(srcfile + " data accuracy test failed.")                                logPMParser.error("PM counter:" + a + "/" + i + "/" + v1 + " value is " + str(                                    srcInfo[a][i][v1]) + ", and the expected result is:" + str(baseInfo[a][i][v1]))                                return -1                        else:                            logPMParser.error(srcfile + " data accuracy test failed.")                            logPMParser.error("PM counter:" + a + "/" + i + "/" + v1 + " is missing.")                            return -1                else:                    logPMParser.error(srcfile + " data accuracy test failed.")                    logPMParser.error("PM DN:" + a + "/" + i + " missing.")                    return -1    for a, b in srcInfo.items():        if (a == "FileHeader"):            for c, d in b.items():                if baseInfo[a].has_key(c) == False:                    logPMParser.error(srcfile + " accuracy test failed ")                    logPMParser.error("extra attribute:" + a + "/" + c + " in " + srcfile)                    return -1        elif (a == "PMData"):            for i, j in b.items():                if baseInfo[a].has_key(i) == False:                    logPMParser.error(srcfile + " accuracy test failed ")                    logPMParser.error("extra PM DN:" + a + "/" + i + " in " + srcfile)                    return -1                else:                    for v1, v2 in j.items():                        if baseInfo[a][i].has_key(v1) == False:                            logPMParser.error(srcfile + " accuracy test failed ")                            logPMParser.error("extra PM counter:" + a + "/" + i + "/" + v1 + " in " + srcfile)                            return -1class PMSaxHandler(xml.sax.ContentHandler):    def __init__(self):        xml.sax.ContentHandler.__init__(self)        logPMParser.info('SAX handler init.')        self.node = {}        self.lics = {}        self.mes = {}        self.isHeader = False        self.headerPara = {}        self.isPmName = False        self.isPMData = False        self.isName = False        self.lic_names = {}        self.me_names = {}        self.pmdata = {}        self.isDN = False        self.isValue = False        self.lic_values = {}        self.me_values = {}        self.value_index = ""        self.name_index = ""        self.isObjectType = False        self.isLic = False        self.isME = False        self.counter = ""        self.isObjectType = False        self.isME = False        self.isPmName = False        self.key = None                self.hasValue = False        self.dn = ""        self.isMeasurement = False    def startElement(self, name, attrs):        if (name == "FileHeader"):            self.isHeader = True            logPMParser.info('Found a header information.')        elif(name == "Measurements"):            self.isMeasurement = True            logPMParser.info("Found a Measurement information")        elif(name == "ObjectType"):            self.isObjectType = True            logPMParser.info('Found a ObjectType information.')        elif(name == "PmName"):            self.isPmName = True            logPMParser.info('Found a PmName information.')        elif(name == "N"):            self.isName = True            self.name_index = attrs["i"].strip().encode('utf-8')        elif(name == "PmData"):            self.isPMData = True            logPMParser.info('Found a PMData information.')        elif (name == "Pm"):            self.isDN = True            self.dn = attrs["Dn"].strip().encode('utf-8')        elif (name == "V"):            self.isValue = True            self.value_index = attrs["i"].strip().encode('utf-8')        self.key = name.strip().encode('utf-8')    def characters(self, content):        content = content.strip().encode('utf-8')        if (self.isHeader):            if (self.key != 'FileHeader' and self.key != 'BeginTime' and self.key != 'EndTime'):                if (self.key is not None):                    self.headerPara[self.key] = content        elif (self.isObjectType and self.key is not None):            if content == "ME":                self.isME = True            elif content == "L":                self.isLic = True        elif (self.isPmName and self.isName and self.isLic):            if(self.key == "N" and self.key is not None):                self.lic_names[self.name_index] = content        elif (self.isPmName and self.isName and self.isME):            if(self.key == "N" and self.key is not None):                self.me_names[self.name_index] = content        elif (self.isDN and self.isValue and self.isLic):            if (self.key == 'V' and self.key is not None):                if (content.find(".")==-1):                    self.lic_values[self.value_index] = int(content)                else:                    self.lic_values[self.value_index] = Decimal(content)                self.hasValue = True        elif (self.isDN and self.isValue and self.isME):            if (self.key == "V" and self.key is not None):                 if (content.find(".")==-1):                    self.me_values[self.value_index] = int(content)                 else:                    self.me_values[self.value_index] = Decimal(content)                 self.hasValue = True    def endElement(self, name):        if (name == self.key):            self.key = None        if(name == "Measurements"):            self.isMeasurement = False            if(self.isLic):                self.isLic = False            elif(self.isME):                self.isME = False        if(name == "ObjectType"):            self.isObjectType = False        if (name == 'FileHeader'):            self.isHeader = False        if (name == 'PmName'):            self.isPmName = False        if (name == 'Pm'):            self.isDN = False            if(self.isLic):                self.lics[self.dn] = self.lic_values                self.lic_values = {}            elif(self.isME):                self.mes[self.dn] = self.me_values                self.me_values={}        if (name == 'V'):            self.isValue = False            if(self.hasValue == False):                if(self.isLic):                    self.lic_values[self.value_index]=""                elif(self.isME):                    self.me_values[self.value_index]=""            self.hasValue = False        if (name == "N"):            self.isName = False        if(name == "PmData"):            self.isPMData = False            if(self.isLic):                for DN, counters in self.lics.items():                    for counter_index, counter_value in counters.items():                        if(self.lic_names.has_key(counter_index)):                            del self.lics[DN][counter_index]                            self.lics[DN].update({self.lic_names[counter_index]:counter_value})                self.pmdata.update(self.lics)                self.lics={}            elif(self.isME):                for DN, counters in self.mes.items():                    for counter_index,counter_value in counters.items():                        if(self.me_names.has_key(counter_index)):                            del self.mes[DN][counter_index]                            self.mes[DN].update({self.me_names[counter_index]:counter_value})                self.pmdata.update(self.mes)                self.mes={}                    def endDocument(self):        self.node["FileHeader"] = self.headerPara        self.node["PMData"] = self.pmdata        logPMParser.info('End the parsing of XML.')def parse_xml_file(xmlpath):    parser = xml.sax.make_parser()    handler = PMSaxHandler()    parser.setContentHandler(handler)    parser.parse(open(xmlpath, 'r'))    return handler.nodedef get_options():    parser = OptionParser(usage="usage: %prog -t <netype> -n <nename> -o <nodeid> [-l <licid>] [-i <interval>] [-p <timestamp>]")    parser.add_option("-i", "--interval", action="store", type="int", dest="interval", default=15,                      help="specify the rop of northbound pm file[5|15]. The default rop is 15")    parser.add_option("-t", "--type", action="store", type="string", dest="ne_type", default="True",                      help="specify the netype")    parser.add_option("-n", "--nename", action="store", type="string", dest="nename", default="True",                      help="specify the nename")    parser.add_option("-o", "--nodeid", action="store", type="string", dest="nodeid", default="True",                      help="specify the nodeid")    parser.add_option("-l", "--licid", action="store", type="string", dest="licid", default="",                      help="specify the licId and no need for NEs of AS, IMSHSS and LTEHSS")    parser.add_option("-p", "--timestamp", action="store", type="string", dest="time", default="",                      help="specify the timestamp back from which to process the pm file[YYmmddHHMM]")    (options, args) = parser.parse_args()    if (options.ne_type == "True"):        print "-t is mandatory to input."        parser.print_help()        return -1    if (options.nename == "True"):        print "-n is mandatory to input."        parser.print_help()        return -1    if (options.nodeid == "True"):        print "-o is mandatory to input."        parser.print_help()        return -1    if (options.ne_type.lower() != 'sgsn' and options.ne_type.lower() != 'mme' and options.ne_type.lower() != 'sgw' and options.ne_type.lower() != 'pgw' and options.ne_type.lower() != 'as' and options.ne_type.lower() != 'sbc' and options.ne_type.lower() != 'imshss' and options.ne_type.lower() != 'ltehss'):        print "Only support NETYPE including SGSN,MME,SGW,PGW,AS,SBC,IMSHSS and LTEHSS."        parser.print_help()        return -1    if (options.interval % 5):        print "incorrect interval.It must be multiples of 5"        parser.print_help()        return -1    if options.time != "":        pattern = re.compile(r'\d{12}')        match = pattern.match(options.time)        if match == None:            print "The input pm_timestamp must be in format of YYmmddHHMM."            parser.print_help()            return -1    return optionsdef addtwodimdict(thedict, key_a, key_b, val):    if key_a in thedict:        thedict[key_a].update({key_b: val})    else:        thedict.update({key_a: {key_b: val}})def get_fileheader_data(netype):    fileheader_path=lic_counters_dir+os.sep+ "fileheader.cfg"    fileheader_data = PyProperties.Properties(fileheader_path).dict_info()    if(options.ne_type.lower()=="imshss" or options.ne_type.lower() == "ltehss"):        fileheader_data["InfoModelReferenced"] = "HSS" + "-PM-V1.0.0"    else:             fileheader_data["InfoModelReferenced"] = options.ne_type.upper() + "-PM-V1.0.0"    return fileheader_datadef get_pm_data_lic(netype):    pm_lic_counter_path = lic_counters_dir + os.sep + netype + ".cfg"    counter_properties_path = counter_properties_dir + os.sep + netype + ".cfg"        counter_properties = load_counter_properties(counter_properties_path)    lic_counters= PyProperties.Properties(pm_lic_counter_path).dict_info()        counters = {}    pmdata_lic = {}        for key, value in lic_counters.items():        if (netype.lower() == "as" or netype.lower() == "imshss" or netype.lower() == "ltehss"):            time, licid = key.split("-")            time = int(time)        else:            time = int(key)            licid = options.licid        # get counters info        counter_value = value.split(",")        for index in range(0, len(counter_value)):            if(counter_value[index]=="\N"):                counters[str(index + 1)] = ""            elif(get_counter_datatype(counter_properties, index, "lic").strip() == "int"):                counters[str(index + 1)] = int(counter_value[index])            elif(get_counter_datatype(counter_properties, index, "lic") == "float"):                #StrToFloat=float(counter_value[index])                counters[str(index+1)] = Decimal(counter_value[index])                            index = index + 1        dn = "DC=Ericsson,SubNetwork=1,ManagedElement=" + options.nodeid + "|" + options.nename + ",L=" + licid        addtwodimdict(pmdata_lic, time, dn, counters)        counters = {}    return pmdata_licdef get_pm_data_me(netype):    pm_me_counter_path = me_counters_dir + os.sep + netype + ".cfg"    counter_properties_path = counter_properties_dir + os.sep + netype + ".cfg"    counter_properties = load_counter_properties(counter_properties_path)        me_counters = PyProperties.Properties(pm_me_counter_path).dict_info()    pmdata_me={}    counters = {}    counters_value = []        for time, value in me_counters.items():        time = int(time)        # get counters info        counter_value = value.split(",")        for index in range(0, len(counter_value)):            if(counter_value[index]=="\N"):                counters[str(index + 1)] = ""            elif(get_counter_datatype(counter_properties, index, "me") == "int"):                counters[str(index + 1)] = int(counter_value[index])            elif(get_counter_datatype(counter_properties, index, "me") == "float"):                counters[str(index+1)] = Decimal(counter_value[index])                            index = index + 1        dn = "DC=Ericsson,SubNetwork=1,ManagedElement=" + options.nodeid + "|" + options.nename        addtwodimdict(pmdata_me, time, dn, counters)        counters = {}    return pmdata_medef get_counter_name_map(datatype):    counter_properties=load_counter_properties(counter_properties_dir + os.sep + options.ne_type.lower() + ".cfg")    counter_map={}    if(datatype == "lic"):        counter_name_list =counter_properties["lic_counter_name"].split(",")    elif(datatype == "me"):        counter_name_list = counter_properties["me_counter_name"].split(",")    if(datatype == "lic"):                i=1        for counters in counter_name_list:            name=counters.split("-")[0][0]            start=int(re.findall(r"\d+",counters.split("-")[0])[0])            end=int(re.findall(r"\d+",counters.split("-")[1])[0])            for index in range(start,end+1):                counter_map[str(i)]=name+str(index)                index=index+1                i=i+1    elif(datatype == "me"):        i=1        for counter in counter_name_list:            counter_map[str(i)]=counter            i=i+1    return counter_map                def update_counter_name_to_real(pmdata,datatype):    counter_name_map=get_counter_name_map(datatype)    for time,lics in pmdata.items():        for DN,counters in lics.items():            for counter_name, counter_value in counters.items():                if (counter_name_map.has_key(counter_name)):                    del counters[counter_name]                    counters.update({counter_name_map[counter_name]:counter_value})        del pmdata[time][DN]        pmdata[time].update({DN:counters})    return pmdata                def get_expect_result(netype):    expect_data = {}     node = {}      fileheader_data = get_fileheader_data(netype)    lic_data = get_pm_data_lic(netype)    me_data = get_pm_data_me(netype)    lic_data=update_counter_name_to_real(lic_data,"lic")    me_data=update_counter_name_to_real(me_data,"me")    time = 0    while time < 60:        node["FileHeader"] = fileheader_data        node["PMData"] = dict(lic_data[time].items() + me_data[time].items())        expect_data[time] = node        node = {}        time = time + 5    return expect_datadef get_expect_result_multi(netype):    node_m = {}    expect_data_m ={}            fileheader_data_5 = get_fileheader_data(netype)    lic_data_5 = get_pm_data_lic(netype)    me_data_5 = get_pm_data_me(netype)    lic_data_m = multi_calculator(lic_data_5, "lic")    me_data_m = multi_calculator(me_data_5,"me")    fileheader_data_m = fileheader_data_5    lic_data_m=update_counter_name_to_real(lic_data_m,"lic")    me_data_m=update_counter_name_to_real(me_data_m, "me")            time=0    while(time<60):        node_m["PMData"] = dict(lic_data_m[time].items() + me_data_m[time].items())        node_m["FileHeader"] = fileheader_data_m                expect_data_m[time] = node_m        node_m = {}        time = time + options.interval    return expect_data_mdef multi_calculator(pmdata_5,datatype):       counter_properties = load_counter_properties(counter_properties_dir + os.sep + options.ne_type.lower() + ".cfg")    new_counters={}    pmdata_m={}        time=0    while time<60:        pmdata=pmdata_5[time]        for DN, counters in pmdata.items():            for counter_name, counter_value in counters.items():                if(counter_value ==""):                    new_counters[counter_name]=""                elif(get_counter_multi_algorithm(counter_properties,int(counter_name)-1,datatype).strip()=="sum"):                    new_counters[counter_name]=sum_counter(DN,counter_name,counter_value,time,datatype)                elif(get_counter_multi_algorithm(counter_properties,int(counter_name)-1,datatype) == "avg"):                    new_counters[counter_name]=avg_counter(DN,counter_name,counter_value,time,datatype)                elif(get_counter_multi_algorithm(counter_properties,int(counter_name)-1,datatype)=="last"):                    new_counters[counter_name]=last_counter(DN,counter_name,counter_value,time,datatype)                elif(get_counter_multi_algorithm(counter_properties,int(counter_name)-1,datatype) =="max"):                    new_counters[counter_name]=max_counter(DN,counter_name,counter_value,time,datatype)            addtwodimdict(pmdata_m, time, DN, new_counters)            new_counters={}                    time=time+options.interval            return pmdata_m        if __name__ == '__main__':    options = get_options()    if options == -1:        exit()    else:        nename = options.nename        nodeid = options.nodeid        licid = options.licid        netype = options.ne_type.lower()    npm_dir = npm_dir_root + os.path.sep + options.nodeid    if (not os.path.exists(npm_dir)):        os.makedirs(npm_dir)    if (options.interval == 5):        expect_data = get_expect_result(netype)    else:        expect_data = get_expect_result_multi(netype)    srcfile = get_file_list()    len_src_file = len(srcfile.items())    if (len_src_file == 0):        print "no required pm files can be found in " + npm_dir        exit()    success_num = 0    fail_num = 0    print "Start PM comparing............"    for time, file in srcfile.items():        if expect_data.has_key(time) == True:            flag = compare_data(file, expect_data[time])            if flag == -1:                fail_num += 1                print file + " accuracy test failed. For failed reason pls refer to Detail.log"            else:                success_num += 1                logPMParser.debug(file + " accuracy test success.")                print file + " accuracy test success"    print "Finish PM . Total:" + str(len_src_file) + " files.Success:" + str(success_num) + " Fail:" + str(        fail_num)